# Gemini CLI Code Review

- model: gemini-2.5-flash-lite
- generated_at: 2026-02-15T13:17:23.341Z
- files_sent: 26
- total_bytes_sent: 194504

Aqui está o code review detalhado do projeto **Gemini CLI (WhatsApp Ml Bot)**.

### Resumo Executivo (Bullets)
- **Arquitetura Sólida para MVP:** O projeto está bem estruturado, com separação clara de responsabilidades (serviços, bot, armazenamento e utilitários).
- **Gerenciamento de Estado:** O uso de uma fila (`p-queue`) para serializar acessos ao banco JSON evita corrupção de dados simples, mas o modelo não escala para alto volume.
- **Robustez de Integração:** Implementação proativa de *retry* para erros do `PolicyAgent` do Mercado Livre e uso de *Structured Outputs* da OpenAI aumentam a confiabilidade.
- **Segurança de Tokens:** O armazenamento de `refresh_token` no `db.json` é funcional, mas carece de criptografia *at-rest*.
- **UX no WhatsApp:** O bot utiliza *typing delays* e agrupamento de fotos para parecer mais humano e menos intrusivo.
- **Tratamento de Erros:** O sistema de captura de `attribute_id` em erros da API do ML é uma excelente sacada para guiar o usuário na correção do anúncio.

---

### Problemas e Riscos por Severidade

#### **ALTO: Condição de Corrida no Estado da Sessão**
No arquivo `src/bot/WhatsAppMlBot.ts`, o método `analyzeSession` executa chamadas assíncronas externas (OpenAI e ML). Embora haja uma verificação de status antes e depois, o estado da sessão no banco de dados pode ser alterado por mensagens do usuário (ex: "cancelar") enquanto a análise está ocorrendo.
- **Arquivo:** `src/bot/WhatsAppMlBot.ts` (linhas 275-300).
- **Risco:** O bot pode sobrescrever um comando de cancelamento ou uma nova entrada do usuário com resultados de uma análise "atrasada".

#### **MÉDIO: Gargalo e Persistência no `JsonDbStore`**
O `JsonDbStore` lê e escreve o arquivo inteiro a cada operação.
- **Arquivo:** `src/storage/store.ts`.
- **Risco:** Conforme o número de sessões cresce, o custo de IO e processamento de JSON cresce exponencialmente. Além disso, `writeFileAtomic` com `rename` é seguro, mas falhas de memória em arquivos muito grandes podem causar perda de dados.

#### **MÉDIO: Loop de Reconexão no Baileys**
O bot tenta reiniciar automaticamente em quase qualquer erro de conexão.
- **Arquivo:** `src/bot/WhatsAppMlBot.ts` (linhas 125-135).
- **Risco:** Se o bot for banido pelo WhatsApp ou se houver um erro de credenciais inválidas (não apenas `loggedOut`), ele entrará em um loop infinito de reinicialização, o que pode agravar o bloqueio do IP ou da conta.

#### **BAIXO: Limites de Memória no Download de Mídia**
O download de imagens é feito via stream, o que é bom, mas não há validação de tamanho antes do processamento.
- **Arquivo:** `src/bot/WhatsAppMlBot.ts` (linhas 175-185).
- **Risco:** Receber múltiplos arquivos muito grandes simultaneamente pode estourar a RAM do processo, especialmente em ambientes limitados.

---

### Melhorias Implementáveis

1.  **Bloqueio de Sessão (Locking):** Adicionar um campo `processing: boolean` ou um *lock* em memória por `sessionId` para evitar que `handleText` processe comandos enquanto `analyzeSession` ou `publishSession` estão em curso.
2.  **Criptografia de Tokens:** Utilizar uma chave mestra (via env) para criptografar o `mlTokens` dentro do `db.json`. Atualmente, se o arquivo `db.json` vazar, o acesso à conta do Mercado Livre é total.
3.  **Paginação/Indexação de Sessões:** Mudar de um objeto único para um sistema de arquivos por dia ou usar um banco embarcado como SQLite se o volume crescer.
4.  **Paralelismo no Upload de Fotos:** Em `publishSession`, os uploads de fotos são sequenciais. Como o ML aceita múltiplos IDs, usar `Promise.all` com um limite de concorrência (ex: 3) aceleraria a publicação.

---

### Observações Específicas

#### **WhatsApp (Baileys)**
- O uso de `WA_ALLOWED_GROUP_IDS` é crítico e está implementado corretamente para evitar que o bot responda em qualquer grupo onde for adicionado.
- **Sugestão:** Implementar um "soft-block" para o bot ignorar mensagens que não sejam imagens ou comandos específicos, economizando processamento de IA em conversas casuais do grupo.

#### **OpenAI Vision**
- O fallback de *Structured Outputs* para `json_object` é resiliente. 
- **Ponto Positivo:** O prompt está bem instruído para não inventar dados (`brand/model: null`), o que é essencial para a saúde da conta do vendedor no ML.

#### **Mercado Livre (API)**
- **OAuth:** A lógica de *refresh* automático em `getAccessToken` está correta e lida bem com a expiração de 6 horas do ML.
- **Atributos:** A função `extractAttributeIdsFromMlError` é pragmática. No entanto, o ML frequentemente retorna erros aninhados. Recomendo validar se o campo `cause` não contém uma estrutura de árvore mais profunda em certos casos de erro de validação.
- **Status Paused:** Implementado conforme solicitado. Isso protege o usuário de erros de precificação da IA.

---

### Testes Automatizados Essenciais

1.  **Unitário - `analyzePrices`:** Testar o comportamento com outliers extremos e com menos de 5 itens (o código atual retorna `null` corretamente, mas deve-se garantir que não quebre).
2.  **Unitário - `parseKeyValueLines`:** Validar casos com múltiplas quebras de linha, espaços extras e símbolos de `=` dentro do valor (ex: `obs=produto=bom`).
3.  **Integração (Mockado) - `publishSession`:** Simular uma falha no 2º upload de imagem e verificar se a sessão volta para `awaiting_user_info` sem deixar lixo no estado.
4.  **E2E - Fluxo de Concorrência:** Testar o envio de 5 fotos seguidas de um comando "cancelar" em menos de 1 segundo para validar a integridade do estado.

### Considerações Finais
O código é de alta qualidade para um ambiente Node.js moderno, utilizando ESM, Typescript rigoroso e boas práticas de logging. A principal preocupação reside na escala da persistência em arquivo e na concorrência de eventos assíncronos do WhatsApp vs. Processamento de IA.
